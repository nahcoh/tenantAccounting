name: Backend Deploy

on:
  push:
    branches: [main]
    paths:
      - 'backend/**'
      - 'docker-compose.prod.yml'
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: backend-deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy-backend:
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4

      - name: Select deployment target
        id: env
        run: |
          echo "EC2_HOST=${{ secrets.PROD_EC2_HOST }}" >> "$GITHUB_OUTPUT"
          echo "EC2_USER=${{ secrets.PROD_EC2_USER }}" >> "$GITHUB_OUTPUT"
          echo "ENVIRONMENT=production" >> "$GITHUB_OUTPUT"

      - name: Create target directory via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ steps.env.outputs.EC2_HOST }}
          port: ${{ secrets.SSH_PORT }}
          username: ${{ steps.env.outputs.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: mkdir -p /home/${{ steps.env.outputs.EC2_USER }}/ziplog

      - name: Copy source code to EC2
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ steps.env.outputs.EC2_HOST }}
          port: ${{ secrets.SSH_PORT }}
          username: ${{ steps.env.outputs.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          source: "backend/**,docker-compose.prod.yml"
          target: "/home/${{ steps.env.outputs.EC2_USER }}/ziplog"
          strip_components: 0

      - name: Deploy backend and verify runtime on EC2
        uses: appleboy/ssh-action@v1.0.3
        env:
          MYSQL_ROOT_PASSWORD: ${{ secrets.MYSQL_ROOT_PASSWORD }}
          MYSQL_DATABASE: ${{ secrets.MYSQL_DATABASE }}
          STORAGE_S3_ENABLED: ${{ secrets.STORAGE_S3_ENABLED }}
          AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
          AWS_S3_PREFIX: ${{ secrets.AWS_S3_PREFIX }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          KAKAO_CLIENT_ID: ${{ secrets.KAKAO_CLIENT_ID }}
          KAKAO_CLIENT_SECRET: ${{ secrets.KAKAO_CLIENT_SECRET }}
          CORS_ALLOWED_ORIGINS: ${{ secrets.CORS_ALLOWED_ORIGINS }}
          AUTH_COOKIE_DOMAIN: ${{ secrets.AUTH_COOKIE_DOMAIN }}
          GITHUB_SHA: ${{ github.sha }}
        with:
          host: ${{ steps.env.outputs.EC2_HOST }}
          port: ${{ secrets.SSH_PORT }}
          username: ${{ steps.env.outputs.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          envs: MYSQL_ROOT_PASSWORD,MYSQL_DATABASE,STORAGE_S3_ENABLED,AWS_S3_BUCKET,AWS_S3_PREFIX,AWS_REGION,AWS_ACCESS_KEY_ID,AWS_SECRET_ACCESS_KEY,JWT_SECRET,GOOGLE_CLIENT_ID,GOOGLE_CLIENT_SECRET,KAKAO_CLIENT_ID,KAKAO_CLIENT_SECRET,CORS_ALLOWED_ORIGINS,AUTH_COOKIE_DOMAIN,GITHUB_SHA
          script: |
            set -euo pipefail

            cd /home/${{ steps.env.outputs.EC2_USER }}/ziplog

            : "${MYSQL_ROOT_PASSWORD:?MYSQL_ROOT_PASSWORD is required}"
            : "${MYSQL_DATABASE:?MYSQL_DATABASE is required}"
            : "${JWT_SECRET:?JWT_SECRET is required}"
            : "${GOOGLE_CLIENT_ID:?GOOGLE_CLIENT_ID is required}"
            : "${GOOGLE_CLIENT_SECRET:?GOOGLE_CLIENT_SECRET is required}"
            : "${KAKAO_CLIENT_ID:?KAKAO_CLIENT_ID is required}"
            : "${KAKAO_CLIENT_SECRET:?KAKAO_CLIENT_SECRET is required}"
            : "${CORS_ALLOWED_ORIGINS:?CORS_ALLOWED_ORIGINS is required}"
            : "${AUTH_COOKIE_DOMAIN:?AUTH_COOKIE_DOMAIN is required}"
            STORAGE_S3_ENABLED="${STORAGE_S3_ENABLED:-false}"
            AWS_REGION="${AWS_REGION:-ap-northeast-2}"
            AWS_S3_PREFIX="${AWS_S3_PREFIX:-checklists}"
            if [ "$STORAGE_S3_ENABLED" = "true" ] && [ -z "${AWS_S3_BUCKET:-}" ]; then
              echo "AWS_S3_BUCKET is required when STORAGE_S3_ENABLED=true"
              exit 1
            fi

            echo "MYSQL_ROOT_PASSWORD=$MYSQL_ROOT_PASSWORD" > .env
            echo "MYSQL_DATABASE=$MYSQL_DATABASE" >> .env
            echo "STORAGE_S3_ENABLED=$STORAGE_S3_ENABLED" >> .env
            echo "AWS_S3_BUCKET=${AWS_S3_BUCKET:-}" >> .env
            echo "AWS_S3_PREFIX=$AWS_S3_PREFIX" >> .env
            echo "AWS_REGION=$AWS_REGION" >> .env
            echo "AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID:-}" >> .env
            echo "AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY:-}" >> .env
            echo "JWT_SECRET=$JWT_SECRET" >> .env
            echo "GOOGLE_CLIENT_ID=$GOOGLE_CLIENT_ID" >> .env
            echo "GOOGLE_CLIENT_SECRET=$GOOGLE_CLIENT_SECRET" >> .env
            echo "KAKAO_CLIENT_ID=$KAKAO_CLIENT_ID" >> .env
            echo "KAKAO_CLIENT_SECRET=$KAKAO_CLIENT_SECRET" >> .env
            echo "CORS_ALLOWED_ORIGINS=$CORS_ALLOWED_ORIGINS" >> .env
            echo "AUTH_COOKIE_DOMAIN=$AUTH_COOKIE_DOMAIN" >> .env
            echo "SPRING_JPA_HIBERNATE_DDL_AUTO=update" >> .env
            echo "APP_COMMIT_SHA=$GITHUB_SHA" >> .env

            mkdir -p backups
            mysql_container_id=$(docker compose -f docker-compose.prod.yml ps -q mysql | head -n1)
            if [ -n "$mysql_container_id" ]; then
              ts=$(date +%Y%m%d_%H%M%S)
              docker exec "$mysql_container_id" sh -lc "mysqldump -uroot -p\"$MYSQL_ROOT_PASSWORD\" \"$MYSQL_DATABASE\"" > "backups/mysql_${ts}.sql"
              find backups -type f -name 'mysql_*.sql' -mtime +7 -delete || true
              echo "Database backup created: backups/mysql_${ts}.sql"
            else
              echo "mysql container not running, skip backup step"
            fi

            docker compose -f docker-compose.prod.yml down --remove-orphans || true
            docker compose -f docker-compose.prod.yml up -d --build --force-recreate --remove-orphans

            backend_container_id=$(docker compose -f docker-compose.prod.yml ps -q backend | head -n1)
            if [ -z "$backend_container_id" ]; then
              echo "Backend container id not found"
              docker compose -f docker-compose.prod.yml ps || true
              docker compose -f docker-compose.prod.yml logs backend --tail=200 || true
              exit 1
            fi

            for i in $(seq 1 40); do
              status=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}{{.State.Status}}{{end}}' "$backend_container_id" 2>/dev/null || echo missing)
              [ -z "$status" ] && status=missing
              echo "backend status: $status (attempt $i/40)"

              if [ "$status" = "healthy" ] || [ "$status" = "running" ]; then
                break
              fi

              if [ "$status" = "unhealthy" ] || [ "$status" = "missing" ]; then
                echo "Backend container is not healthy"
                docker compose -f docker-compose.prod.yml logs backend --tail=200 || true
                exit 1
              fi

              sleep 5
            done

            final_status=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}{{.State.Status}}{{end}}' "$backend_container_id" 2>/dev/null || echo missing)
            [ -z "$final_status" ] && final_status=missing
            if [ "$final_status" != "healthy" ] && [ "$final_status" != "running" ]; then
              echo "Backend did not become healthy in time"
              docker compose -f docker-compose.prod.yml logs backend --tail=200 || true
              exit 1
            fi

            if docker exec "$backend_container_id" sh -lc "strings /app/app.jar | grep -q 'queryParam(\"accessToken\")'"; then
              echo "Old OAuth query-token runtime signature detected"
              exit 1
            fi

            code=$(curl -s -o /dev/null -w '%{http_code}' http://localhost:8080/api/auth/me || true)
            if [ "$code" != "401" ] && [ "$code" != "200" ]; then
              echo "Unexpected /api/auth/me status: $code"
              exit 1
            fi

            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.RunningFor}}"

      - name: Backend deployment summary
        run: |
          echo "## Backend Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "- Environment: ${{ steps.env.outputs.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "- EC2 Host: ${{ steps.env.outputs.EC2_HOST }}" >> $GITHUB_STEP_SUMMARY
          echo "- Branch: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- Commit: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
